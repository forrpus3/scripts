local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local character, humanoid, rootPart

-- KEY SYSTEM
local CORRECT_KEY = "o.goddy"
local keyAuthenticated = false

local function createKeySystem()
	local keyGui = Instance.new("ScreenGui")
	keyGui.ResetOnSpawn = false
	keyGui.Parent = player:WaitForChild("PlayerGui")
	
	local keyFrame = Instance.new("Frame")
	keyFrame.Size = UDim2.new(0, 300, 0, 150)
	keyFrame.Position = UDim2.new(0.5, -150, 0.5, -75)
	keyFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	keyFrame.BorderSizePixel = 2
	keyFrame.BorderColor3 = Color3.fromRGB(220, 53, 69)
	keyFrame.Parent = keyGui
	
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Size = UDim2.new(1, 0, 0, 40)
	titleLabel.Position = UDim2.new(0, 0, 0, 0)
	titleLabel.Text = "KEY SYSTEM"
	titleLabel.BackgroundColor3 = Color3.fromRGB(220, 53, 69)
	titleLabel.TextColor3 = Color3.new(1, 1, 1)
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextSize = 18
	titleLabel.BorderSizePixel = 0
	titleLabel.Parent = keyFrame
	
	local keyBox = Instance.new("TextBox")
	keyBox.Size = UDim2.new(0.9, 0, 0, 35)
	keyBox.Position = UDim2.new(0.05, 0, 0, 50)
	keyBox.PlaceholderText = "Enter Key..."
	keyBox.Text = ""
	keyBox.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	keyBox.TextColor3 = Color3.new(1, 1, 1)
	keyBox.Font = Enum.Font.Gotham
	keyBox.TextSize = 14
	keyBox.BorderSizePixel = 0
	keyBox.ClearTextOnFocus = false
	keyBox.Parent = keyFrame
	
	local submitButton = Instance.new("TextButton")
	submitButton.Size = UDim2.new(0.9, 0, 0, 35)
	submitButton.Position = UDim2.new(0.05, 0, 0, 95)
	submitButton.Text = "SUBMIT"
	submitButton.BackgroundColor3 = Color3.fromRGB(40, 167, 69)
	submitButton.TextColor3 = Color3.new(1, 1, 1)
	submitButton.Font = Enum.Font.GothamBold
	submitButton.TextSize = 16
	submitButton.BorderSizePixel = 0
	submitButton.Parent = keyFrame
	
	local function checkKey()
		if keyBox.Text == CORRECT_KEY then
			keyAuthenticated = true
			keyGui:Destroy()
			initializeScript()
		else
			keyBox.Text = ""
			keyBox.PlaceholderText = "Wrong Key! Try Again..."
			submitButton.BackgroundColor3 = Color3.fromRGB(220, 53, 69)
			task.wait(1)
			submitButton.BackgroundColor3 = Color3.fromRGB(40, 167, 69)
			keyBox.PlaceholderText = "Enter Key..."
		end
	end
	
	submitButton.MouseButton1Click:Connect(checkKey)
	
	keyBox.FocusLost:Connect(function(enterPressed)
		if enterPressed then
			checkKey()
		end
	end)
end

local function initializeScript()
	if not keyAuthenticated then return end

local function bindCharacter(char)
	character = char
	humanoid = char:WaitForChild("Humanoid")
	rootPart = char:WaitForChild("HumanoidRootPart")
end

bindCharacter(player.Character or player.CharacterAdded:Wait())
player.CharacterAdded:Connect(bindCharacter)

local remotes = ReplicatedStorage:WaitForChild("Remotes")
local promptPlayerLaunch = remotes:WaitForChild("promptPlayerLaunch")
local topsFolder = workspace:WaitForChild("Tops")

local TARGET_POSITION = Vector3.new(
	415.53619384765625,
	120.1265640258789,
	-86.57369232177734
)

local FACING_POSITION = Vector3.new(
	424.9053955078125,
	112.94845581054688,
	-72.63363647460938
)

local RESPAWN_POSITION = Vector3.new(
	775.6261596679688,
	118.49895477294922,
	-37.37122344970703
)

local POSITION_RADIUS = 3
local MOVE_RATE = 0.15
local ROTATE_SPEED = 10
local RESPAWN_RADIUS = 5
local STUCK_CHECK_INTERVAL = 2
local STUCK_DISTANCE_THRESHOLD = 2
local UNSTUCK_OFFSET_DISTANCE = 8

local isRunning = false
local inPosition = false
local initialFired = false
local lastPosition = nil
local lastMoveTime = 0
local isUnstucking = false
local isRecharging = false
local noclipConnection = nil

local healthConnection = nil
local rotateConnection = nil
local modelConnection = nil
local energyConnection = nil

local gui = Instance.new("ScreenGui")
gui.ResetOnSpawn = false
gui.Parent = player:WaitForChild("PlayerGui")

local button = Instance.new("TextButton")
button.Size = UDim2.new(0, 180, 0, 60)
button.Position = UDim2.new(0.5, -90, 0.1, 0)
button.Text = "START"
button.BackgroundColor3 = Color3.fromRGB(220, 53, 69)
button.TextColor3 = Color3.new(1,1,1)
button.Font = Enum.Font.GothamBold
button.TextSize = 18
button.BorderSizePixel = 0
button.Parent = gui

local keyLabel = Instance.new("TextLabel")
keyLabel.Size = UDim2.new(0, 180, 0, 30)
keyLabel.Position = UDim2.new(0.5, -90, 0.1, 65)
keyLabel.Text = "Press O to toggle"
keyLabel.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
keyLabel.TextColor3 = Color3.new(1, 1, 1)
keyLabel.Font = Enum.Font.Gotham
keyLabel.TextSize = 14
keyLabel.BorderSizePixel = 0
keyLabel.Parent = gui

-- Energy monitoring system
local function getCharacter()
	local char = player.Character or player.CharacterAdded:Wait()
	return char, char:WaitForChild("Humanoid")
end

local function getEnergyBar()
	return player.PlayerGui
		:WaitForChild("HUD")
		:WaitForChild("Main HUD")
		:WaitForChild("Energy")
		:WaitForChild("Progress")
end

local function findNearbyProximityPrompt(position, maxDistance)
	local closestPrompt = nil
	local closestDistance = maxDistance
	
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("ProximityPrompt") and obj.Enabled then
			local parent = obj.Parent
			local promptPos = nil
			
			if parent:IsA("BasePart") then
				promptPos = parent.Position
			elseif parent:IsA("Model") then
				if parent.PrimaryPart then
					promptPos = parent.PrimaryPart.Position
				else
					local part = parent:FindFirstChildWhichIsA("BasePart", true)
					if part then
						promptPos = part.Position
					end
				end
			elseif parent:IsA("Attachment") then
				promptPos = parent.WorldPosition
			end
			
			if promptPos then
				local dist = (promptPos - position).Magnitude
				if dist < closestDistance then
					closestDistance = dist
					closestPrompt = obj
				end
			end
		end
	end
	
	return closestPrompt
end

local function fireProximityPrompt(prompt)
	if prompt then
		pcall(function()
			if fireproximityprompt then
				fireproximityprompt(prompt, 0, true)
			elseif fire_proximity_prompt then
				fire_proximity_prompt(prompt)
			else
				local oldHoldDuration = prompt.HoldDuration
				prompt.HoldDuration = 0
				prompt:InputHoldBegin()
				task.wait(0.1)
				prompt:InputHoldEnd()
				prompt.HoldDuration = oldHoldDuration
			end
		end)
	end
end

-- Start energy monitoring (check every 10 seconds)
local function startEnergyMonitoring()
	if energyConnection then
		task.cancel(energyConnection)
	end
	
	energyConnection = task.spawn(function()
		local energyBar = getEnergyBar()
		while isRunning do
			local energy = energyBar.Size.X.Scale
			if energy <= 0 then
				-- Set recharging flag to stop main movement loop
				isRecharging = true
				
				-- Continuously move to respawn position until reached
				local reachedPosition = false
				local maxAttempts = 60 -- 30 seconds max (60 * 0.5)
				
				for i = 1, maxAttempts do
					local _, hum = getCharacter()
					local char = player.Character
					
					if char and char:FindFirstChild("HumanoidRootPart") then
						local dist = (char.HumanoidRootPart.Position - RESPAWN_POSITION).Magnitude
						
						if dist <= RESPAWN_RADIUS then
							reachedPosition = true
							break
						else
							-- Keep moving to respawn position
							hum:MoveTo(RESPAWN_POSITION)
						end
					end
					
					task.wait(0.5)
				end
				
				-- If player reached the position, wait 2 seconds then fire prompt
				if reachedPosition then
					task.wait(2)
					
					local char = player.Character
					if char and char:FindFirstChild("HumanoidRootPart") then
						-- Find and fire nearby proximity prompt
						local prompt = findNearbyProximityPrompt(RESPAWN_POSITION, 15)
						if prompt then
							print("Found proximity prompt, firing...")
							fireProximityPrompt(prompt)
							
							-- Wait for energy to restore
							task.wait(2)
						else
							print("No proximity prompt found near respawn position")
						end
					end
				else
					print("Failed to reach respawn position")
				end
				
				-- Reset recharging flag to resume normal movement
				isRecharging = false
			end
			task.wait(10)
		end
	end)
end

local function startFacing()
	if rotateConnection then rotateConnection:Disconnect() end

	rotateConnection = RunService.RenderStepped:Connect(function(dt)
		if not isRunning or not rootPart or isRecharging then return end

		local dir = FACING_POSITION - rootPart.Position
		local flat = Vector3.new(dir.X, 0, dir.Z)
		if flat.Magnitude == 0 then return end

		local targetCF = CFrame.new(rootPart.Position, rootPart.Position + flat)
		local alpha = 1 - math.exp(-ROTATE_SPEED * dt)

		rootPart.CFrame = rootPart.CFrame:Lerp(targetCF, alpha)
	end)
end

local function stopFacing()
	if rotateConnection then
		rotateConnection:Disconnect()
		rotateConnection = nil
	end
end

local function startNoclip()
	if noclipConnection then
		noclipConnection:Disconnect()
	end
	
	noclipConnection = RunService.Stepped:Connect(function()
		if character then
			-- Disable collision for all parts (full noclip)
			for _, part in pairs(character:GetDescendants()) do
				if part:IsA("BasePart") then
					part.CanCollide = false
				end
			end
			
			-- Keep player above ground level
			if rootPart and humanoid then
				local rayOrigin = rootPart.Position
				local rayDirection = Vector3.new(0, -100, 0)
				local raycastParams = RaycastParams.new()
				raycastParams.FilterType = Enum.RaycastFilterType.Exclude
				raycastParams.FilterDescendantsInstances = {character}
				
				local rayResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
				
				if rayResult then
					local groundY = rayResult.Position.Y
					local playerY = rootPart.Position.Y
					local minHeight = groundY + (humanoid.HipHeight + 2)
					
					-- If player is below minimum height, push them up
					if playerY < minHeight then
						rootPart.CFrame = CFrame.new(
							rootPart.Position.X,
							minHeight,
							rootPart.Position.Z
						) * (rootPart.CFrame - rootPart.Position)
					end
				end
			end
		end
	end)
end

local function stopNoclip()
	if noclipConnection then
		noclipConnection:Disconnect()
		noclipConnection = nil
	end
	
	-- Re-enable collisions
	if character then
		for _, part in pairs(character:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = true
			end
		end
	end
end

local function startHealthMonitor(model)
	if healthConnection then
		healthConnection:Disconnect()
	end

	local firedLow = false
	local firedZero = false

	local function checkHealth()
		if not isRunning then return end

		local health = model:GetAttribute("Health")
		if not health then return end

		if inPosition and health < 80 and not firedLow then
			firedLow = true
			promptPlayerLaunch:FireServer(1, player.Character)
		end

		if health == 0 and not firedZero then
			firedZero = true
			promptPlayerLaunch:FireServer(1, player.Character)
		end

		if health >= 80 then
			firedLow = false
		end

		if health > 0 then
			firedZero = false
		end

		if not inPosition then
			firedLow = false
		end
	end

	checkHealth()
	healthConnection = model:GetAttributeChangedSignal("Health"):Connect(checkHealth)
end

local function watchModels()
	if modelConnection then
		modelConnection:Disconnect()
	end

	local id = tostring(player.UserId)

	local existing = topsFolder:FindFirstChild(id)
	if existing then
		startHealthMonitor(existing)
	end

	modelConnection = topsFolder.ChildAdded:Connect(function(child)
		if child.Name == id then
			startHealthMonitor(child)
		end
	end)
end

local function startMovement()
	task.spawn(function()
		while isRunning do
			if humanoid and rootPart and not isUnstucking and not isRecharging then
				local dist = (rootPart.Position - TARGET_POSITION).Magnitude

				if dist > POSITION_RADIUS then
					inPosition = false
					humanoid:MoveTo(TARGET_POSITION)
				else
					inPosition = true

					if not initialFired then
						initialFired = true
						promptPlayerLaunch:FireServer(1, player.Character)
					end
				end
			end
			task.wait(MOVE_RATE)
		end
	end)
	
	-- Stuck detection and pathfinding system
	task.spawn(function()
		while isRunning do
			task.wait(STUCK_CHECK_INTERVAL)
			
			if rootPart and humanoid and not isUnstucking and not isRecharging then
				local currentPos = rootPart.Position
				local currentTime = tick()
				
				-- Check if player is stuck (hasn't moved much)
				if lastPosition then
					local distMoved = (currentPos - lastPosition).Magnitude
					local timeDiff = currentTime - lastMoveTime
					
					-- If barely moved in 2 seconds and not at target
					if distMoved < STUCK_DISTANCE_THRESHOLD and timeDiff >= STUCK_CHECK_INTERVAL then
						local distToTarget = (currentPos - TARGET_POSITION).Magnitude
						
						if distToTarget > POSITION_RADIUS then
							-- Player is stuck, try to pathfind around obstacle
							isUnstucking = true
							
							humanoid:Move(Vector3.new(0, 0, 0)) -- Stop current movement
							task.wait(0.1)
							
							-- Calculate direction to target
							local dirToTarget = (TARGET_POSITION - currentPos).Unit
							
							-- Try moving to the side (perpendicular to the direction)
							local rightVector = Vector3.new(-dirToTarget.Z, 0, dirToTarget.X)
							local leftVector = Vector3.new(dirToTarget.Z, 0, -dirToTarget.X)
							
							-- Randomly choose left or right to avoid getting stuck in a loop
							local sideVector = math.random() > 0.5 and rightVector or leftVector
							local sidePosition = currentPos + (sideVector * UNSTUCK_OFFSET_DISTANCE)
							
							-- Move to the side first
							humanoid:MoveTo(sidePosition)
							task.wait(1.5)
							
							-- Reset unstucking flag
							isUnstucking = false
							
							-- The main movement loop will now resume moving to target
						end
					end
				end
				
				lastPosition = currentPos
				lastMoveTime = currentTime
			end
		end
	end)
end

local function start()
	if isRunning then return end
	isRunning = true

	button.Text = "STOP"
	button.BackgroundColor3 = Color3.fromRGB(40, 167, 69)

	startFacing()
	startMovement()
	watchModels()
	startEnergyMonitoring()
	startNoclip()
end

local function stop()
	isRunning = false

	button.Text = "START"
	button.BackgroundColor3 = Color3.fromRGB(220, 53, 69)

	stopFacing()
	stopNoclip()
	
	lastPosition = nil
	lastMoveTime = 0
	isUnstucking = false
	isRecharging = false

	if healthConnection then
		healthConnection:Disconnect()
		healthConnection = nil
	end

	if modelConnection then
		modelConnection:Disconnect()
		modelConnection = nil
	end
	
	if energyConnection then
		task.cancel(energyConnection)
		energyConnection = nil
	end
end

button.MouseButton1Click:Connect(function()
	if isRunning then
		stop()
	else
		start()
	end
end)

-- Keybind to toggle (O key)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	
	if input.KeyCode == Enum.KeyCode.O then
		if isRunning then
			stop()
		else
			start()
		end
	end
end)

end -- End of initializeScript()

-- Start key system on load
createKeySystem()
